/**
 * Strava API v3
 * Strava API
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { DetailedSegment } from '../model/detailedSegment';
import { ExplorerResponse } from '../model/explorerResponse';
import { Fault } from '../model/fault';
import { SegmentLeaderboard } from '../model/segmentLeaderboard';
import { SummarySegment } from '../model/summarySegment';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class SegmentsService {

    protected basePath = 'https://www.strava.com/api/v3';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Explore segments
     * Returns the top 10 segments matching a specified query.
     * @param bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param activityType Desired activity type.
     * @param minCat The minimum climbing category.
     * @param maxCat The maximum climbing category.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, observe?: 'body', reportProgress?: boolean): Observable<ExplorerResponse>;
    public exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExplorerResponse>>;
    public exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExplorerResponse>>;
    public exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bounds === null || bounds === undefined) {
            throw new Error('Required parameter bounds was null or undefined when calling exploreSegments.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bounds) {
            queryParameters = queryParameters.set('bounds', bounds.join(COLLECTION_FORMATS['csv']));
        }
        if (activityType !== undefined && activityType !== null) {
            queryParameters = queryParameters.set('activity_type', <any>activityType);
        }
        if (minCat !== undefined && minCat !== null) {
            queryParameters = queryParameters.set('min_cat', <any>minCat);
        }
        if (maxCat !== undefined && maxCat !== null) {
            queryParameters = queryParameters.set('max_cat', <any>maxCat);
        }

        let headers = this.defaultHeaders;

        // authentication (strava_oauth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExplorerResponse>(`${this.basePath}/segments/explore`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Segment Leaderboard
     * Returns the specified segment leaderboard.
     * @param id The identifier of the segment leaderboard.
     * @param gender Filter by gender.
     * @param ageGroup Summit Feature. Filter by age group.
     * @param weightClass Summit Feature. Filter by weight class.
     * @param following Filter by friends of the authenticated athlete.
     * @param clubId Filter by club.
     * @param dateRange Filter by date range.
     * @param contextEntries 
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLeaderboardBySegmentId(id: number, gender?: 'M' | 'F', ageGroup?: '0_19' | '20_24' | '25_34' | '35_44' | '45_54' | '55_64' | '65_69' | '70_74' | '75_plus', weightClass?: '0_124' | '125_149' | '150_164' | '165_179' | '180_199' | '200_224' | '225_249' | '250_plus' | '0_54' | '55_64' | '65_74' | '75_84' | '85_94' | '95_104' | '105_114' | '115_plus', following?: boolean, clubId?: number, dateRange?: 'this_year' | 'this_month' | 'this_week' | 'today', contextEntries?: number, page?: number, perPage?: number, observe?: 'body', reportProgress?: boolean): Observable<SegmentLeaderboard>;
    public getLeaderboardBySegmentId(id: number, gender?: 'M' | 'F', ageGroup?: '0_19' | '20_24' | '25_34' | '35_44' | '45_54' | '55_64' | '65_69' | '70_74' | '75_plus', weightClass?: '0_124' | '125_149' | '150_164' | '165_179' | '180_199' | '200_224' | '225_249' | '250_plus' | '0_54' | '55_64' | '65_74' | '75_84' | '85_94' | '95_104' | '105_114' | '115_plus', following?: boolean, clubId?: number, dateRange?: 'this_year' | 'this_month' | 'this_week' | 'today', contextEntries?: number, page?: number, perPage?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SegmentLeaderboard>>;
    public getLeaderboardBySegmentId(id: number, gender?: 'M' | 'F', ageGroup?: '0_19' | '20_24' | '25_34' | '35_44' | '45_54' | '55_64' | '65_69' | '70_74' | '75_plus', weightClass?: '0_124' | '125_149' | '150_164' | '165_179' | '180_199' | '200_224' | '225_249' | '250_plus' | '0_54' | '55_64' | '65_74' | '75_84' | '85_94' | '95_104' | '105_114' | '115_plus', following?: boolean, clubId?: number, dateRange?: 'this_year' | 'this_month' | 'this_week' | 'today', contextEntries?: number, page?: number, perPage?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SegmentLeaderboard>>;
    public getLeaderboardBySegmentId(id: number, gender?: 'M' | 'F', ageGroup?: '0_19' | '20_24' | '25_34' | '35_44' | '45_54' | '55_64' | '65_69' | '70_74' | '75_plus', weightClass?: '0_124' | '125_149' | '150_164' | '165_179' | '180_199' | '200_224' | '225_249' | '250_plus' | '0_54' | '55_64' | '65_74' | '75_84' | '85_94' | '95_104' | '105_114' | '115_plus', following?: boolean, clubId?: number, dateRange?: 'this_year' | 'this_month' | 'this_week' | 'today', contextEntries?: number, page?: number, perPage?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLeaderboardBySegmentId.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (gender !== undefined && gender !== null) {
            queryParameters = queryParameters.set('gender', <any>gender);
        }
        if (ageGroup !== undefined && ageGroup !== null) {
            queryParameters = queryParameters.set('age_group', <any>ageGroup);
        }
        if (weightClass !== undefined && weightClass !== null) {
            queryParameters = queryParameters.set('weight_class', <any>weightClass);
        }
        if (following !== undefined && following !== null) {
            queryParameters = queryParameters.set('following', <any>following);
        }
        if (clubId !== undefined && clubId !== null) {
            queryParameters = queryParameters.set('club_id', <any>clubId);
        }
        if (dateRange !== undefined && dateRange !== null) {
            queryParameters = queryParameters.set('date_range', <any>dateRange);
        }
        if (contextEntries !== undefined && contextEntries !== null) {
            queryParameters = queryParameters.set('context_entries', <any>contextEntries);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (perPage !== undefined && perPage !== null) {
            queryParameters = queryParameters.set('per_page', <any>perPage);
        }

        let headers = this.defaultHeaders;

        // authentication (strava_oauth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SegmentLeaderboard>(`${this.basePath}/segments/${encodeURIComponent(String(id))}/leaderboard`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Starred Segments
     * List of the authenticated athlete&#39;s starred segments. Private segments are filtered out unless requested by a token with read_all scope.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLoggedInAthleteStarredSegments(page?: number, perPage?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SummarySegment>>;
    public getLoggedInAthleteStarredSegments(page?: number, perPage?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SummarySegment>>>;
    public getLoggedInAthleteStarredSegments(page?: number, perPage?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SummarySegment>>>;
    public getLoggedInAthleteStarredSegments(page?: number, perPage?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (perPage !== undefined && perPage !== null) {
            queryParameters = queryParameters.set('per_page', <any>perPage);
        }

        let headers = this.defaultHeaders;

        // authentication (strava_oauth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SummarySegment>>(`${this.basePath}/segments/starred`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Segment
     * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
     * @param id The identifier of the segment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSegmentById(id: number, observe?: 'body', reportProgress?: boolean): Observable<DetailedSegment>;
    public getSegmentById(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DetailedSegment>>;
    public getSegmentById(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DetailedSegment>>;
    public getSegmentById(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSegmentById.');
        }

        let headers = this.defaultHeaders;

        // authentication (strava_oauth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<DetailedSegment>(`${this.basePath}/segments/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Star Segment
     * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
     * @param id The identifier of the segment to star.
     * @param starred If true, star the segment; if false, unstar the segment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public starSegment(id: number, starred: boolean, observe?: 'body', reportProgress?: boolean): Observable<DetailedSegment>;
    public starSegment(id: number, starred: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DetailedSegment>>;
    public starSegment(id: number, starred: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DetailedSegment>>;
    public starSegment(id: number, starred: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling starSegment.');
        }

        if (starred === null || starred === undefined) {
            throw new Error('Required parameter starred was null or undefined when calling starSegment.');
        }

        let headers = this.defaultHeaders;

        // authentication (strava_oauth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void | HttpParams; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (starred !== undefined) {
            formParams = formParams.append('starred', <any>starred) || formParams;
        }

        return this.httpClient.put<DetailedSegment>(`${this.basePath}/segments/${encodeURIComponent(String(id))}/starred`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
